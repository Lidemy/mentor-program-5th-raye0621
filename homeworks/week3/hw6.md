## hw1：好多星星
這一題算是滿基本的，感覺是經典的函式填空法XDD，只是自我檢討的那個炫技的解法好...好難。

```javascript
function solve(lines){
  let n = Number(lines[0])
  console.log(
    Array.from({length: n})
      .map(
        (item, index) => '*'.repeat(index + 1)
      )
      .join('\n')
  )
}
```

## hw2：水仙花數
這題是 LIOJ 上第一個看起來很複雜的題目，當初三月解時是聽老師的課解出來的，這次再做一次時知道解題的流程但是卻忘記要怎麼判斷幾位數，還是看了老師的解答才知道比較快的方式。

## hw3：判斷質數
這題看了自我檢討後修改了判斷質數函式的輸出，使輸出的值為布林值。
功能歸功能，log 歸 log！，「寫出可以重複使用的程式碼」
養成寫程式碼的好習慣，題目要求甚麼功能不要直接印出，寫出考量到以後可以繼續使用的程式比較重要。

## hw4：判斷迴文

這題我是直接判斷字串頭尾元素是否相同，自我檢討卻是建立一個 reverse 的 function 再比較，比較聰明些，不用再多想迴文要怎麼寫。

單行的看得懂但是很難直接寫出來。－..－
```javascript
function solve(lines) {
  let str = lines[0]
  console.log(str.split('').reverse().join('') === str ? 'True' : 'False')
}
```

## hw5：聯誼順序比大小

這題因為範圍的問題卡了兩天，後來才發現提問區已經有兩個人問過了Orz，但是知道問題出在哪後，後面因為三元運算子還沒有很熟悉又用錯、又浪費了很多時間。

本周檢討中的程式碼比我原本的的短 2/3，看到可以簡潔在簡潔真的是嘆為觀止
大概總結一下是如何濃縮的：
1. 用 early return 提早把相似的情況建立，減少 else 的使用，使函式可讀性變高。
自己使用的話還是無法直接完美的想出來，可以先做完再思考哪些可以提早return、哪些函式的else if 或 else 其實是可以去掉。

2. A B 互 調 
ab互調的邏輯好酷哦，看到這種解題的答案就會懷疑一下自己以後真的可以把這種邏輯思維信手捻來嗎XD 
為何可以互換：
比大就是 A 大回傳 'A'，B 大 回傳 'B'
比小就是 A 大回傳 'B'，B 大 回傳 'A'
判斷的結果都一樣，只有回傳值倒反過來，所以可以先判斷是比大還比小，
再先把條件倒反過來，這樣邏輯也會是正確的。轉一下轉一下。

3. 不須一個一個比較字串中的元素大小，因為字串比較的是字典序，如果兩個字串長度相同，字典序為數字大小的順序，所以直接比較字串就好。不用再寫落落長的迴圈。


4. 記錄一下第二次卡很久錯誤的寫法
主要是不熟悉三元運算子，少想到一步，雖然本地端測試都沒有問題。

情境：
判斷誰比較大要先判斷誰的字串長度比較長，較長的就大，而如果一樣長就一個一個抓出比較從頭開始判斷誰的元素比較大。

現字串已經一樣長，要個別判斷字串中的元素大小，如果同位置 a 先大於 b，那就是 a 比較大，反之。
```javascript
錯誤的寫法
for (let i = 0; i < lengthA; i++){
	return a[i] > b[i] ? 'A' : 'B'
}
return 'DRAW'
```
這樣會少考慮到 a[i] === b[i] 的條件
只會有 
a[i] > b[i] 是 true 或是 false 兩種情形
true => 回傳 'A'
false = > 回傳 'B'
但是 false 的情形還有包含 a[i] === b[i]
導致 a[i] < b[i] 和 a[i] === b[i] 都會回傳 'B'

應該要改成以下，把條件都清楚地列出
```javascript
正確的寫法
for (let j = 0; j < lengthA; j++){
	if (a[j] > b[j]){
		return 'A'
	} else if (a[j] < b[j]){
		return 'B'
	}
}
return 'DRAW'
```

心得：
最後錯的地方抓好久才抓出來，而最後一題照著檢討一步一步的優化，體會到寫程式就是瘋狂的「提煉再提煉、濃縮再濃縮」，最後能用最簡單的邏輯做出來才是優秀的程式碼，還有好長一段路要走Q_Q。

謝謝助教批改，辛苦了<3